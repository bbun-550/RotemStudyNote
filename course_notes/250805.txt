250805

>실습 파일명
>sort_selection.py : 선택 정렬
>sort_insertion.py : 삽입 정렬
>sort_merge.py : 병합 정렬
>sort_quick.py : 퀵 정렬
>sort_bubble : 버블 정렬
>---
>pandas02.py 
>pandas03.py



[알고리즘 시각화](https://www.hackerearth.com/practice/algorithms/sorting/merge-sort/visualize/)

#### 선택정렬 sort selection

예제) 
10명의 키가 제각각인 사람들이 평지에 서 있다.
- 10명 중에서 키가 가장 작은 한 사람 뽑는다
- 9명 중에서 키가 작은 한 사람 뽑아서 줄 세운다 ...
- ... 가장 큰 사람이 결국 마지막에 위치
- `pop()` 

1. (공간 복잡도 생각 없이, 메모리 사용) 새로운 기억 장소 활용
2. (메모리 절감) 

#### 삽입 정렬 insertion sort
예제)
- 첫 번째 사람을 추출
- 두 번째 사람을 첫 번째와 비교, 작으면 앞에 위치시킴
- 세 번째 사람을 기존 사람들이랑 비교해서 작으면 앞, 크면 뒤에 위치시킴
- ...

방법1

방법2
- j : i+1	
- key 활용 : 삽입 대상. 담아놓는 용도
1. i = 1, key = 4 pass
2. i = 2, key = 5 pass
3. i = 3, key = 1. 2,4,5를 한 칸씩 뒤로 밀고, 0자리에 1 삽입
4. i = 4, key = 3. 4,5를 한 칸씩 뒤로 밀고, 2자리에 3 삽입 



#### 병합 정렬
예제)
- 10명이 있다. 두 그룹으로 나눈다.
- 각 두 그룹을 또 두 그룹 씩 나눈다. 나눌 수 없을 때까지.
- 



#### 퀵 정렬
- 기준점을 주고 정렬하는 방식
- 나누고 합치는 방식 : 재귀함수 활용 recursive
- 주어진 배열에서 하나의 요소를 선택하고 이를 pivot으로 삼는다
예제)
- 10명의 사람. 기준이 될 사람을 임의로 뽑는다(주로 마지막 사람 또는 기준점을 마지막으로 보냄)
- 기준보다 작은 사람은 왼쪽으로, 큰 사람은 오른쪽으로
- 왼쪽 마지막 사람을 기준점을 잡고, 똑같이 정렬



#### 버블 정렬
- 인접한 두 개의 원소를 비교하여 자리를 교환하는 방식



---
#### 순서 글 표현

- 병합 정렬

방법1
[a,b,c,d,e,f,g,h]
1. 리스트를 둘로 쪼갠다 `len(list) // 2` `list[mid:]
2. 둘로 나눈 리스트를 또 반으로 쪼갠다 : 재귀함수
3. 하나만 남을 때까지 반으로 쪼갠다

a와 b가 나왔다.
a,b 비교해서 작은 것을 최종 출력될 장소에 넣는다.
b도 뒤따라서 최종 출력될 장소에 넣는다. [a,b]

다음 쪼개진 c,d

---

- 퀵 정렬

방법1
[6,8,3,1,2,4,7,5]
1. 기준점을 잡는다. 주로 마지막 값을 기준값으로 지정함
2. 첫 번째 숫자부터 기준값과 비교해서 작으면 왼쪽 상자에 담고, 크면 오른쪽 상자에 담는다.
3. 재귀함수 반복
	1. 왼쪽 상자 : [3,1,2,4], 오른쪽 상자 : [6,8,7]
	2. 왼쪽 상자에서 마지막 값을 기준값으로 지정한다.
	3. 기준값과 비교. [3,1,2] 또 왼쪽 상자에 담기고, 오른쪽 상자에는 아무것도 없다.
	4. 왼쪽 상자 : [3,1,2], 오른쪽 없음
		1. (재귀함수) 2를 기준 값으로 지정
		2. 왼쪽 상자 : 1 , 오른쪽 상자 : 3
		3. [1] + [2] + [3]
	5. [1,2,3] + [4]
	6. 오른쪽 상자 [6,8,7]
	7. 7을 기준값으로 지정
	8. 왼쪽 상자 : 6 , 오른쪽 상자 : 8
	9. [6] + [7] + [8]
4. 왼쪽 상자[1,2,3,4] + 기준점[5] + 오른쪽 상자 [6,7,8]
---